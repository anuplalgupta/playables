<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coin Runner - YouTube Playable</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        #game-canvas {
            display: block;
            margin: 0 auto;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
        }
        .ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .back-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000;
            font-size: 16px;
        }
        .back-button:hover {
            background: rgba(0,0,0,0.9);
        }
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 200;
            display: none;
        }
        .restart-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 15px;
        }
        .restart-btn:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <button class="back-button" onclick="window.location.href='../index.html'">‚Üê Back to Games</button>
    
    <!-- YouTube Playables SDK - MUST be loaded first -->
    <script src="https://www.youtube.com/game_api/v1"></script>
    
    <div id="game-container">
        <div class="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Coins: <span id="coins">0</span></div>
            <div>Speed: <span id="speed">1</span></div>
            <div style="font-size: 14px; opacity: 0.7; margin-top: 10px;">Created by <strong>Alg</strong></div>
        </div>
        
        <div class="game-over" id="gameOver">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Coins Collected: <span id="finalCoins">0</span></p>
            <button class="restart-btn" onclick="restartGame()">Play Again</button>
            <p style="font-size: 12px; opacity: 0.6; margin-top: 15px;">Created by <strong>Alg</strong></p>
        </div>
        
        <canvas id="game-canvas"></canvas>
    </div>

    <script>
        // YouTube Playables SDK Integration
        class YouTubePlayablesIntegration {
            constructor() {
                this.isAudioEnabled = true;
                this.isPaused = false;
                this.setupSDK();
            }

            setupSDK() {
                if (typeof ytgame === 'undefined') {
                    console.warn('YouTube Playables SDK not loaded - running in local mode');
                    this.simulateSDK();
                    return;
                }

                this.isAudioEnabled = ytgame.system.isAudioEnabled();
                ytgame.system.onAudioEnabledChange((enabled) => {
                    this.isAudioEnabled = enabled;
                    console.log('Audio enabled:', enabled);
                });

                ytgame.system.onPause(() => {
                    this.isPaused = true;
                    console.log('Game paused');
                });

                ytgame.system.onResume(() => {
                    this.isPaused = false;
                    console.log('Game resumed');
                });
            }

            simulateSDK() {
                console.log('Running in local testing mode - YouTube SDK functions simulated');
            }

            notifyFirstFrameReady() {
                if (typeof ytgame !== 'undefined' && ytgame.game.firstFrameReady) {
                    ytgame.game.firstFrameReady();
                    console.log('First frame ready');
                } else {
                    console.log('Simulated: First frame ready');
                }
            }

            notifyGameReady() {
                if (typeof ytgame !== 'undefined' && ytgame.game.gameReady) {
                    ytgame.game.gameReady();
                    console.log('Game ready');
                } else {
                    console.log('Simulated: Game ready');
                }
            }
        }

        // Initialize YouTube integration
        const youtubeIntegration = new YouTubePlayablesIntegration();

        // Game variables
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state
        let gameRunning = false;
        let gameSpeed = 1;
        let score = 0;
        let coins = 0;
        let gameTime = 0;

        // Player
        const player = {
            x: 100,
            y: canvas.height - 150,
            width: 40,
            height: 60,
            lane: 1, // 0 = left, 1 = center, 2 = right
            isJumping: false,
            jumpHeight: 0,
            maxJumpHeight: 100,
            isSliding: false,
            slideTime: 0,
            lastLaneChange: 0 // For lane change cooldown
        };

        // Lanes
        const lanes = [
            canvas.width * 0.2,
            canvas.width * 0.5,
            canvas.width * 0.8
        ];

        // Obstacles and coins
        let obstacles = [];
        let coinList = [];
        let backgroundElements = [];

        // Input handling
        const keys = {
            left: false,
            right: false,
            up: false,
            down: false
        };

        // Initialize game
        function initGame() {
            gameRunning = true;
            score = 0;
            coins = 0;
            gameTime = 0;
            gameSpeed = 1;
            obstacles = [];
            coinList = [];
            backgroundElements = [];
            
            player.x = lanes[1];
            player.y = canvas.height - 150;
            player.lane = 1;
            player.isJumping = false;
            player.jumpHeight = 0;
            player.isSliding = false;
            player.slideTime = 0;
            player.lastLaneChange = 0;

            // Initialize background elements
            for (let i = 0; i < 20; i++) {
                backgroundElements.push({
                    x: Math.random() * canvas.width,
                    y: -i * 100,
                    type: Math.random() > 0.5 ? 'building' : 'tree',
                    width: Math.random() * 100 + 50,
                    height: Math.random() * 200 + 100
                });
            }

            document.getElementById('gameOver').style.display = 'none';
        }

        // Generate obstacles
        function generateObstacle() {
            if (Math.random() < 0.02 * gameSpeed) {
                const lane = Math.floor(Math.random() * 3);
                obstacles.push({
                    x: lanes[lane],
                    y: -50,
                    width: 30,
                    height: 50,
                    lane: lane,
                    type: 'obstacle'
                });
            }
        }

        // Generate coins
        function generateCoin() {
            if (Math.random() < 0.03 * gameSpeed) {
                const lane = Math.floor(Math.random() * 3);
                coinList.push({
                    x: lanes[lane] + 15,
                    y: -30,
                    width: 20,
                    height: 20,
                    lane: lane,
                    type: 'coin',
                    collected: false
                });
            }
        }

        // Update player position
        function updatePlayer() {
            // Handle lane switching with debouncing and cooldown
            const currentTime = Date.now();
            const laneChangeCooldown = 200; // 200ms cooldown between lane changes
            
            if (keys.left && player.lane > 0 && (currentTime - player.lastLaneChange) > laneChangeCooldown) {
                player.lane--;
                player.lastLaneChange = currentTime;
                keys.left = false; // Reset key to prevent continuous switching
            }
            if (keys.right && player.lane < 2 && (currentTime - player.lastLaneChange) > laneChangeCooldown) {
                player.lane++;
                player.lastLaneChange = currentTime;
                keys.right = false; // Reset key to prevent continuous switching
            }

            // Smooth lane transition
            const targetX = lanes[player.lane];
            player.x += (targetX - player.x) * 0.2;

            // Handle jumping
            if (keys.up && !player.isJumping && !player.isSliding) {
                player.isJumping = true;
                player.jumpHeight = 0;
            }

            if (player.isJumping) {
                player.jumpHeight += 8;
                if (player.jumpHeight >= player.maxJumpHeight) {
                    player.isJumping = false;
                }
            } else if (player.jumpHeight > 0) {
                player.jumpHeight -= 8;
            }

            // Handle sliding
            if (keys.down && !player.isSliding && !player.isJumping) {
                player.isSliding = true;
                player.slideTime = 0;
            }

            if (player.isSliding) {
                player.slideTime++;
                if (player.slideTime > 30) {
                    player.isSliding = false;
                }
            }

            // Update player Y position
            player.y = canvas.height - 150 - player.jumpHeight;
        }

        // Update game objects
        function updateGame() {
            if (!gameRunning || youtubeIntegration.isPaused) return;

            gameTime++;
            gameSpeed = 1 + Math.floor(gameTime / 1000) * 0.1;

            // Update player
            updatePlayer();

            // Generate new obstacles and coins
            generateObstacle();
            generateCoin();

            // Update obstacles
            obstacles.forEach((obstacle, index) => {
                obstacle.y += 5 * gameSpeed;
                if (obstacle.y > canvas.height) {
                    obstacles.splice(index, 1);
                }
            });

            // Update coins
            coinList.forEach((coin, index) => {
                if (!coin.collected) {
                    coin.y += 5 * gameSpeed;
                    if (coin.y > canvas.height) {
                        coinList.splice(index, 1);
                    }
                }
            });

            // Update background
            backgroundElements.forEach(element => {
                element.y += 2 * gameSpeed;
                if (element.y > canvas.height) {
                    element.y = -200;
                    element.x = Math.random() * canvas.width;
                }
            });

            // Check collisions
            checkCollisions();

            // Update score
            score += Math.floor(gameSpeed);
        }

        // Check collisions
        function checkCollisions() {
            const playerRect = {
                x: player.x - player.width/2,
                y: player.y - (player.isSliding ? player.height/2 : player.height),
                width: player.width,
                height: player.isSliding ? player.height/2 : player.height
            };

            // Check obstacle collisions
            obstacles.forEach(obstacle => {
                if (obstacle.lane === player.lane) {
                    const obstacleRect = {
                        x: obstacle.x - obstacle.width/2,
                        y: obstacle.y,
                        width: obstacle.width,
                        height: obstacle.height
                    };

                    if (isColliding(playerRect, obstacleRect)) {
                        gameOver();
                    }
                }
            });

            // Check coin collisions
            coinList.forEach(coin => {
                if (!coin.collected && coin.lane === player.lane) {
                    const coinRect = {
                        x: coin.x - coin.width/2,
                        y: coin.y - coin.height/2,
                        width: coin.width,
                        height: coin.height
                    };

                    if (isColliding(playerRect, coinRect)) {
                        coin.collected = true;
                        coins++;
                    }
                }
            });
        }

        // Collision detection
        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // Game over
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalCoins').textContent = coins;
            document.getElementById('gameOver').style.display = 'block';
        }

        // Restart game
        function restartGame() {
            initGame();
        }

        // Animation variables
        let animationTime = 0;

        // Polyfill for roundRect (for older browsers)
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
                this.beginPath();
                this.moveTo(x + radius, y);
                this.lineTo(x + width - radius, y);
                this.quadraticCurveTo(x + width, y, x + width, y + radius);
                this.lineTo(x + width, y + height - radius);
                this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                this.lineTo(x + radius, y + height);
                this.quadraticCurveTo(x, y + height, x, y + height - radius);
                this.lineTo(x, y + radius);
                this.quadraticCurveTo(x, y, x + radius, y);
                this.closePath();
            };
        }

        // Render game
        function render() {
            animationTime += 0.1;
            
            // Clear canvas
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw background elements
            backgroundElements.forEach(element => {
                ctx.fillStyle = element.type === 'building' ? '#666' : '#4CAF50';
                ctx.fillRect(element.x, element.y, element.width, element.height);
            });

            // Draw tracks
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            lanes.forEach(laneX => {
                ctx.beginPath();
                ctx.moveTo(laneX, 0);
                ctx.lineTo(laneX, canvas.height);
                ctx.stroke();
            });

            // Draw obstacles with animated shapes
            obstacles.forEach(obstacle => {
                drawAnimatedObstacle(obstacle);
            });

            // Draw coins with animation
            coinList.forEach(coin => {
                if (!coin.collected) {
                    drawAnimatedCoin(coin);
                }
            });

            // Draw player with animation
            drawAnimatedPlayer();

            // Update UI
            document.getElementById('score').textContent = score;
            document.getElementById('coins').textContent = coins;
            document.getElementById('speed').textContent = gameSpeed.toFixed(1);
        }

        // Draw animated player
        function drawAnimatedPlayer() {
            const playerHeight = player.isSliding ? player.height/2 : player.height;
            const playerY = player.y - playerHeight;
            const centerX = player.x;
            const centerY = playerY + playerHeight/2;

            // Player body (rounded rectangle)
            ctx.fillStyle = '#2196F3';
            ctx.strokeStyle = '#1976D2';
            ctx.lineWidth = 2;
            
            // Create rounded rectangle
            const radius = 8;
            ctx.beginPath();
            ctx.roundRect(centerX - player.width/2, playerY, player.width, playerHeight, radius);
            ctx.fill();
            ctx.stroke();

            // Player head (circle)
            const headRadius = 12;
            const headY = playerY + 15;
            ctx.fillStyle = '#FFE0B2';
            ctx.beginPath();
            ctx.arc(centerX, headY, headRadius, 0, Math.PI * 2);
            ctx.fill();

            // Animated eyes
            const eyeOffset = Math.sin(animationTime * 3) * 2;
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(centerX - 4 + eyeOffset, headY - 2, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(centerX + 4 + eyeOffset, headY - 2, 2, 0, Math.PI * 2);
            ctx.fill();

            // Animated mouth
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            if (player.isJumping) {
                // Happy mouth when jumping
                ctx.arc(centerX, headY + 2, 4, 0, Math.PI);
            } else {
                // Normal mouth
                ctx.moveTo(centerX - 3, headY + 2);
                ctx.lineTo(centerX + 3, headY + 2);
            }
            ctx.stroke();

            // Arms (animated)
            const armSwing = Math.sin(animationTime * 4) * 5;
            ctx.strokeStyle = '#FFE0B2';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - player.width/2, playerY + 20);
            ctx.lineTo(centerX - player.width/2 - 10 + armSwing, playerY + 30);
            ctx.moveTo(centerX + player.width/2, playerY + 20);
            ctx.lineTo(centerX + player.width/2 + 10 - armSwing, playerY + 30);
            ctx.stroke();

            // Legs (animated)
            const legSwing = Math.sin(animationTime * 6) * 3;
            ctx.strokeStyle = '#1976D2';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - 5, playerY + playerHeight);
            ctx.lineTo(centerX - 8 + legSwing, playerY + playerHeight + 15);
            ctx.moveTo(centerX + 5, playerY + playerHeight);
            ctx.lineTo(centerX + 8 - legSwing, playerY + playerHeight + 15);
            ctx.stroke();
        }

        // Draw animated obstacles
        function drawAnimatedObstacle(obstacle) {
            const centerX = obstacle.x;
            const centerY = obstacle.y + obstacle.height/2;
            
            // Obstacle body (diamond shape)
            ctx.fillStyle = '#FF5722';
            ctx.strokeStyle = '#D84315';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(centerX, obstacle.y); // Top
            ctx.lineTo(centerX + obstacle.width/2, centerY); // Right
            ctx.lineTo(centerX, obstacle.y + obstacle.height); // Bottom
            ctx.lineTo(centerX - obstacle.width/2, centerY); // Left
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Animated warning symbol
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Pulsing effect
            const pulse = Math.sin(animationTime * 8) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw animated coins
        function drawAnimatedCoin(coin) {
            const centerX = coin.x;
            const centerY = coin.y;
            
            // Coin outer ring
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#FFC107';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, coin.width/2, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Animated spinning effect
            const spinAngle = animationTime * 4;
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(spinAngle);
            
            // Inner coin design
            ctx.fillStyle = '#FFF59D';
            ctx.beginPath();
            ctx.arc(0, 0, coin.width/3, 0, Math.PI * 2);
            ctx.fill();
            
            // Coin symbol ($)
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 8px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('$', 0, 3);
            
            ctx.restore();

            // Sparkle effect
            const sparkleCount = 3;
            for (let i = 0; i < sparkleCount; i++) {
                const angle = (animationTime * 2 + i * Math.PI * 2 / sparkleCount) % (Math.PI * 2);
                const sparkleX = centerX + Math.cos(angle) * (coin.width/2 + 5);
                const sparkleY = centerY + Math.sin(angle) * (coin.width/2 + 5);
                
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.sin(animationTime * 6 + i) * 0.5 + 0.5})`;
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Game loop
        function gameLoop() {
            updateGame();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Input handling
        function handleKeyDown(e) {
            switch(e.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keys.left = true;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keys.right = true;
                    break;
                case 'ArrowUp':
                case 'w':
                case 'W':
                case ' ':
                    keys.up = true;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    keys.down = true;
                    break;
            }
        }

        function handleKeyUp(e) {
            switch(e.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keys.left = false;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keys.right = false;
                    break;
                case 'ArrowUp':
                case 'w':
                case 'W':
                case ' ':
                    keys.up = false;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    keys.down = false;
                    break;
            }
        }

        // Touch controls
        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            // Determine which lane was touched
            if (x < canvas.width * 0.4) {
                keys.left = true;
                setTimeout(() => keys.left = false, 100);
            } else if (x > canvas.width * 0.6) {
                keys.right = true;
                setTimeout(() => keys.right = false, 100);
            } else {
                // Center area - jump or slide based on Y position
                if (y < canvas.height * 0.5) {
                    keys.up = true;
                    setTimeout(() => keys.up = false, 100);
                } else {
                    keys.down = true;
                    setTimeout(() => keys.down = false, 100);
                }
            }
        }

        // Event listeners
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        canvas.addEventListener('touchstart', handleTouch, { passive: false });
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (x < canvas.width * 0.4) {
                keys.left = true;
                setTimeout(() => keys.left = false, 100);
            } else if (x > canvas.width * 0.6) {
                keys.right = true;
                setTimeout(() => keys.right = false, 100);
            } else {
                if (y < canvas.height * 0.5) {
                    keys.up = true;
                    setTimeout(() => keys.up = false, 100);
                } else {
                    keys.down = true;
                    setTimeout(() => keys.down = false, 100);
                }
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            lanes[0] = canvas.width * 0.2;
            lanes[1] = canvas.width * 0.5;
            lanes[2] = canvas.width * 0.8;
        });

        // Initialize and start game
        initGame();
        gameLoop();

        // Notify YouTube that first frame is ready
        youtubeIntegration.notifyFirstFrameReady();

        // Notify YouTube that game is ready
        setTimeout(() => {
            youtubeIntegration.notifyGameReady();
        }, 1000);
    </script>
</body>
</html>
